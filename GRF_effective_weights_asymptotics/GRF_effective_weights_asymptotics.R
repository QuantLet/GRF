rm(list=ls())
library(grf)
library(ggplot2)
library(glue)
#install.packages('ks')
library(ks)
set.seed(42)


get_x = function(n, c){
  X = matrix(sort(runif(n,-c, c)), nrow = n)
  colnames(X) = 'X1'
  return(X)
}
get_x_grid = function(n, c){
  X = matrix(seq(-c, c, length.out = n), nrow = n)
  colnames(X) = 'X1'
  return(X)
}
polynomial = function(x, p){
  X = matrix(1, nrow = nrow(x), ncol = ncol(x) * p + 1)
  cols = c('const')
  for (j in 1:ncol(x)){
    for (i in 1:p) {
      X[, (j - 1) * ncol(x) + i + 1] = x[, j] ** i
      cols = c(cols, glue("{colnames(x)[j]}^{i}"))
    }
  }
  colnames(X) = cols
  return(X)
}
theta_polynomial = function(x, p, beta){
  return(polynomial(x, p) %*% beta)
}

get_y = function(X, theta, sigma, seed=NULL){
  set.seed(NULL)
  n = nrow(X)
  return(theta(X) + rnorm(n, 0, sigma))
}

tau = c(0.5)
sig = 1
width = 0.2
beta = c(0, 1, 0, 4)
p = 3
c = 1
grids = 30
reps = 100

rfs = list()
rmse_results = list()

for (n in c(500, 1000, 2000)){
  sup_diffs = numeric(reps)   # Store sup-norm results for current n
  set.seed(123)
  for (rep in 1:reps) {  
    X = get_x(n, c)
    theta = function(X) theta_polynomial(X, p, beta)
    Y = get_y(X, theta, sig, 42)
    rfs[[as.character(n)]] = rf = grf::quantile_forest(X, Y, quantiles = tau, seed = 42)
    
    X_test = get_x_grid(grids, 0.8)  # New test set
    Y_test = get_y(X_test, theta, sig, 42)
    theta_test = theta(X_test)
    theta_hat = predict(rf, X_test)$predictions
    alpha = get_forest_weights(rf, X_test)  # Compute weights for test set
    
   # kde_fit<- ks::kde(Y)  # Kernel density estimation
    #f_Y <- - predict(kde_fit, x= theta_test)
    
    # kde can be estimated for the model errors (generated by standard normal distribution) 
    # and evaluated at zero, that makes the pseudo estimator more precise
    
    f_Y = - 1 / sqrt(2 * pi)   # We use true density of f(0) for N(0,1), which is 1/sqrt(2*pi)
    psi_matrix = sapply(theta_test, function(theta_t) tau - (Y <= theta_t))
    
    #epsilon_tilde = sapply(seq_along(theta_test), function(i) - f_Y^(-1) * psi_matrix[,i])
    epsilon_tilde_2 = - f_Y^(-1) * psi_matrix
    
    theta_tilde = theta_test + diag(as.matrix(alpha %*% epsilon_tilde))
    
    #Compute sup-norm of the absolute difference
    sup_diffs[rep] = max(abs(theta_hat - theta_tilde))
  }
  
  # Compute RMSE comparing sup-norms to true theta
  rmse = mean(sup_diffs) 
  rmse_results[[as.character(n)]] = rmse
  
  if (rep == 1){
  fn = glue(
    'qRF_polynom___beta{paste(beta, collapse="_")}___',
    'theta_tilde___',
    'q{formatC(tau*100, width=3, flag="0")}___',
    'sigma{formatC(sig*100, width=3, flag="0")}___',
    'n{formatC(as.integer(n), width=4, flag="0")}',
    '.png'
  )
  
  png(file = fn, res = 100)
  plot(X_test[, 'X1'], Y_test, type = 'p', pch = 20, cex = 0.09, xlab='X', main = glue("n = {n}"))
  lines(X_test[, 'X1'], theta_tilde, col = 'red', lwd = 2)
  lines(X_test[, 'X1'], theta_hat, col = 'darkgreen', lwd = 2)
  lines(X_test[, 'X1'], theta_test, col = 'blue', lty=2)
  legend("bottomright", legend = c("True Theta", "Theta Tilde", "Theta Hat"), 
        col = c("blue", "red", "green"), lty = c(2, 1, 1), cex = 0.8)
  dev.off()
  }
}

# Print RMSE results
print(rmse_results)

